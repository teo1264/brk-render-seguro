#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üìÅ ARQUIVO: processor/monitor_brk.py
üíæ ONDE SALVAR: brk-monitor-seguro/processor/monitor_brk.py
üì¶ FUN√á√ÉO: Monitor autom√°tico BRK - orquestra√ß√£o simples
üîß DESCRI√á√ÉO: Usa m√©todos que J√Å EXISTEM em EmailProcessor
üë®‚Äçüíº AUTOR: Sidney Gubitoso, auxiliar tesouraria adm maua

üö® DEPEND√äNCIAS OBRIGAT√ìRIAS:
   üìÅ Este m√≥dulo DEPENDE de outros m√≥dulos na pasta processor/:
   
   ‚úÖ processor/email_processor.py (OBRIGAT√ìRIO)
      ‚îî‚îÄ M√©todos usados:
         ‚Ä¢ diagnosticar_pasta_brk() - estat√≠sticas da pasta
         ‚Ä¢ buscar_emails_novos() - busca emails por per√≠odo  
         ‚Ä¢ extrair_pdfs_do_email() - extra√ß√£o completa PDFs
         ‚Ä¢ log_consolidado_email() - logs estruturados bonitos
         ‚Ä¢ obter_estatisticas_avancadas() - stats do sistema
   
   ‚úÖ processor/database_brk.py (OPCIONAL - via EmailProcessor)
      ‚îî‚îÄ Usado indiretamente se EmailProcessor tem DatabaseBRK integrado
      ‚îî‚îÄ M√©todos: salvar_fatura(), obter_estatisticas()
   
   ‚ö†Ô∏è IMPORTANTE:
   - Este monitor N√ÉO cria funcionalidades novas
   - Apenas ORQUESTRA m√©todos que j√° existem
   - Se EmailProcessor falhar, este monitor falha tamb√©m
   - Estrutura modular: auth/ + processor/ + admin/

üìã FUNCIONAMENTO:
   ‚Ä¢ Roda em thread daemon (n√£o bloqueia Flask)
   ‚Ä¢ Verifica emails a cada 10 minutos automaticamente
   ‚Ä¢ Exibe logs estruturados no Render
   ‚Ä¢ Usa apenas m√©todos seguros e testados
"""

import time
import threading
from datetime import datetime
from typing import Optional


class MonitorBRK:
    """
    Monitor autom√°tico para emails BRK.
    
    USA APENAS m√©todos que J√Å EXISTEM:
    - diagnosticar_pasta_brk()
    - buscar_emails_novos() 
    - extrair_pdfs_do_email()
    - log_consolidado_email()
    
    N√ÉO cria funcionalidades novas, s√≥ ORQUESTRA.
    """
    
    def __init__(self, email_processor):
        """
        Inicializar monitor com processador existente.
        
        Args:
            email_processor: Inst√¢ncia de EmailProcessor j√° configurada
        """
        self.processor = email_processor
        self.ativo = False
        self.thread_monitor = None
        self.intervalo_minutos = 30
        
        # üîç VALIDAR DEPEND√äNCIAS OBRIGAT√ìRIAS
        self._validar_dependencias()
        
        print(f"üìä Monitor BRK inicializado")
        print(f"   ‚è∞ Intervalo: {self.intervalo_minutos} minutos")
        print(f"   üîß Usando m√©todos existentes do EmailProcessor")
        print(f"   ‚úÖ Depend√™ncias validadas com sucesso")

    def _validar_dependencias(self):
        """
        Valida se EmailProcessor tem todos os m√©todos necess√°rios.
        Falha rapidamente se depend√™ncias n√£o est√£o dispon√≠veis.
        """
        metodos_obrigatorios = [
            'diagnosticar_pasta_brk',
            'buscar_emails_novos', 
            'extrair_pdfs_do_email',
            'log_consolidado_email',
            'obter_estatisticas_avancadas'
        ]
        
        metodos_faltando = []
        
        for metodo in metodos_obrigatorios:
            if not hasattr(self.processor, metodo):
                metodos_faltando.append(metodo)
        
        if metodos_faltando:
            erro_msg = f"‚ùå EmailProcessor est√° faltando m√©todos obrigat√≥rios: {', '.join(metodos_faltando)}"
            erro_msg += f"\nüí° Verifique se processor/email_processor.py est√° completo e consistente"
            raise AttributeError(erro_msg)
        
        # Valida√ß√£o adicional - inst√¢ncia n√£o None
        if not self.processor:
            raise ValueError("‚ùå EmailProcessor n√£o pode ser None")
        
        # Valida√ß√£o adicional - autentica√ß√£o
        if not hasattr(self.processor, 'auth') or not self.processor.auth:
            raise ValueError("‚ùå EmailProcessor deve ter autentica√ß√£o configurada")

    def exibir_estatisticas_pasta(self):
        """
        Exibe estat√≠sticas da pasta BRK usando m√©todo existente.
        USA: diagnosticar_pasta_brk() que J√Å EXISTE
        """
        try:
            print(f"üìä ESTAT√çSTICAS PASTA BRK:")
            
            # ‚úÖ USAR m√©todo que J√Å EXISTE
            stats = self.processor.diagnosticar_pasta_brk()
            
            if stats.get('status') == 'sucesso':
                print(f"   üìß Total na pasta: {stats.get('total_geral', 0):,} emails")
                print(f"   üìÖ M√™s atual: {stats.get('mes_atual', 0)} emails")
                print(f"   ‚è∞ √öltimas 24h: {stats.get('ultimas_24h', 0)} emails")
            else:
                print(f"   ‚ùå Erro obtendo estat√≠sticas: {stats.get('erro', 'Desconhecido')}")
                
        except Exception as e:
            print(f"   ‚ùå Erro nas estat√≠sticas: {e}")

    def processar_emails_novos(self):
        """
        Processa emails novos dos √∫ltimos 10 minutos.
        USA: buscar_emails_novos() + extrair_pdfs_do_email() que J√Å EXISTEM
        """
        try:
            print(f"üîç Processando emails novos (√∫ltimos {self.intervalo_minutos} min)...")
            
            # ‚úÖ USAR m√©todo que J√Å EXISTE - 10 minutos = 0.0069 dias
            dias_atras = self.intervalo_minutos / (24 * 60)  # Converter minutos para dias
            emails = self.processor.buscar_emails_novos(dias_atras)
            
            if not emails:
                print(f"üì≠ Nenhum email novo encontrado")
                return
            
            print(f"üìß {len(emails)} emails novos encontrados")
            
            # Processar cada email
            emails_processados = 0
            pdfs_processados = 0
            
            for email in emails:
                try:
                    # ‚úÖ USAR m√©todo que J√Å EXISTE
                    pdfs_dados = self.processor.extrair_pdfs_do_email(email)
                    
                    if pdfs_dados:
                        # ‚úÖ USAR m√©todo que J√Å EXISTE para logs bonitos
                        self.processor.log_consolidado_email(email, pdfs_dados)
                        
                        emails_processados += 1
                        pdfs_processados += len(pdfs_dados)
                        
                        # Log resumido adicional
                        for pdf in pdfs_dados:
                            if pdf.get('dados_extraidos_ok', False):
                                cdc = pdf.get('Codigo_Cliente', 'N/A')
                                casa = pdf.get('Casa de Ora√ß√£o', 'N/A')
                                valor = pdf.get('Valor', 'N/A')
                                print(f"  üíæ Processado: CDC {cdc} ‚Üí {casa} ‚Üí R$ {valor}")
                    
                except Exception as e:
                    print(f"  ‚ùå Erro processando email: {e}")
                    continue
            
            # Resumo final
            print(f"‚úÖ Processamento conclu√≠do:")
            print(f"   üìß Emails processados: {emails_processados}")
            print(f"   üìé PDFs extra√≠dos: {pdfs_processados}")
            
        except Exception as e:
            print(f"‚ùå Erro no processamento: {e}")

   def executar_ciclo_completo(self):
    """
    Executa ciclo completo: emails + planilha integrada
    ‚úÖ NOVO: Inclui atualiza√ß√£o autom√°tica da planilha
    """
    timestamp = datetime.now().strftime('%H:%M:%S')
    print(f"\nüîÑ [{timestamp}] MONITOR BRK INTEGRADO - Ciclo completo")
    print(f"=" * 55)
    
    try:
        # 1. ETAPA EMAILS (l√≥gica existente)
        print("üìß ETAPA 1: Processamento de emails")
        self.exibir_estatisticas_pasta()
        print()
        self.processar_emails_novos()
        
        # 2. ETAPA PLANILHA (NOVA)
        print(f"\nüìä ETAPA 2: Atualiza√ß√£o planilha BRK")
        self.atualizar_planilha_automatica()
        
    except Exception as e:
        print(f"‚ùå Erro no ciclo integrado: {e}")
    
    print(f"=" * 55)
    print(f"‚è∞ Pr√≥ximo ciclo em {self.intervalo_minutos} minutos")

    def atualizar_planilha_automatica(self):
    """
    NOVA FUN√á√ÉO: Atualizar planilha com sistema backup inteligente
    """
    try:
        print("üìä Gerando planilha atualizada...")
        
        # Importar m√≥dulos necess√°rios
        from processor.excel_brk import ExcelGeneratorBRK
        from processor.planilha_backup import salvar_planilha_inteligente
        
        # Gerar dados da planilha
        excel_generator = ExcelGeneratorBRK()
        dados_planilha = excel_generator.gerar_excel_bytes()
        
        if dados_planilha:
            print("üìä Dados da planilha gerados com sucesso")
            
            # Usar sistema backup inteligente
            sucesso = salvar_planilha_inteligente(self.processor.auth, dados_planilha)
            
            if sucesso:
                print("‚úÖ Planilha atualizada com sucesso")
            else:
                print("‚ùå Falha no salvamento da planilha")
        else:
            print("‚ùå Erro gerando dados da planilha")
            
    except ImportError as e:
        print(f"‚ùå M√≥dulo n√£o encontrado: {e}")
        print("‚ö†Ô∏è Verifique se processor/excel_brk.py e processor/planilha_backup.py existem")
    except Exception as e:
        print(f"‚ùå Erro atualizando planilha: {e}")      

    def iniciar_monitoramento(self):
        """
        Inicia monitoramento em background.
        Thread n√£o-blocking para n√£o travar Flask.
        """
        if self.ativo:
            print(f"‚ö†Ô∏è Monitor j√° est√° ativo")
            return
        
        try:
            self.ativo = True
            
            # Criar thread daemon (n√£o impede shutdown do app)
            self.thread_monitor = threading.Thread(
                target=self.loop_monitoramento,
                daemon=True,
                name="MonitorBRK"
            )
            
            self.thread_monitor.start()
            print(f"‚úÖ Monitor BRK iniciado em background")
            
            # Executar primeiro ciclo imediatamente (opcional)
            # threading.Thread(target=self.executar_ciclo_completo, daemon=True).start()
            
        except Exception as e:
            print(f"‚ùå Erro iniciando monitor: {e}")
            self.ativo = False

    def parar_monitoramento(self):
        """
        Para o monitoramento.
        """
        if not self.ativo:
            print(f"‚ö†Ô∏è Monitor n√£o est√° ativo")
            return
        
        print(f"üõë Parando monitor BRK...")
        self.ativo = False
        
        # Aguardar thread terminar (m√°ximo 5 segundos)
        if self.thread_monitor and self.thread_monitor.is_alive():
            self.thread_monitor.join(timeout=5)
        
        print(f"‚úÖ Monitor BRK parado")

    def status_monitor(self):
        """
        Retorna status atual do monitor.
        
        Returns:
            Dict: Status do monitoramento
        """
        return {
            "ativo": self.ativo,
            "intervalo_minutos": self.intervalo_minutos,
            "thread_viva": self.thread_monitor.is_alive() if self.thread_monitor else False,
            "processador_ok": bool(self.processor),
            "metodos_disponiveis": {
                "diagnosticar_pasta_brk": hasattr(self.processor, 'diagnosticar_pasta_brk'),
                "buscar_emails_novos": hasattr(self.processor, 'buscar_emails_novos'),
                "extrair_pdfs_do_email": hasattr(self.processor, 'extrair_pdfs_do_email'),
                "log_consolidado_email": hasattr(self.processor, 'log_consolidado_email')
            }
        }

    def executar_ciclo_manual(self):
        """
        Executa um ciclo manual para testes.
        √ötil para debug sem aguardar timer.
        """
        print(f"üß™ EXECU√á√ÉO MANUAL - Teste do monitor")
        self.executar_ciclo_completo()


# ============================================================================
# FUN√á√ïES DE UTILIDADE PARA APP.PY
# ============================================================================
def verificar_dependencias_monitor(email_processor) -> dict:
    """
    Verifica depend√™ncias para monitor integrado (emails + planilha)
    ‚úÖ ATUALIZADO: Inclui verifica√ß√£o de planilha
    """
    metodos_obrigatorios = [
        'diagnosticar_pasta_brk',
        'buscar_emails_novos',
        'extrair_pdfs_do_email', 
        'log_consolidado_email'
    ]
    
    resultado = {
        "dependencias_ok": True,
        "email_processor_valido": bool(email_processor),
        "autenticacao_ok": False,
        "excel_generator_ok": False,
        "planilha_backup_ok": False,
        "onedrive_brk_ok": False,
        "metodos_disponivel": {},
        "metodos_faltando": [],
        "observacoes": []
    }
    
    # Verifica√ß√µes b√°sicas existentes...
    if not email_processor:
        resultado["dependencias_ok"] = False
        resultado["observacoes"].append("‚ùå EmailProcessor √© None")
        return resultado
    
    # Verificar autentica√ß√£o
    if hasattr(email_processor, 'auth') and email_processor.auth:
        resultado["autenticacao_ok"] = True
    else:
        resultado["observacoes"].append("‚ö†Ô∏è Autentica√ß√£o n√£o configurada")
    
    # Verificar m√©todos obrigat√≥rios
    for metodo in metodos_obrigatorios:
        disponivel = hasattr(email_processor, metodo)
        resultado["metodos_disponivel"][metodo] = disponivel
        
        if not disponivel:
            resultado["metodos_faltando"].append(metodo)
            resultado["dependencias_ok"] = False
    
    # NOVAS VERIFICA√á√ïES: Planilha
    try:
        from processor.excel_brk import ExcelGeneratorBRK
        resultado["excel_generator_ok"] = True
        resultado["observacoes"].append("‚úÖ ExcelGeneratorBRK dispon√≠vel")
    except ImportError:
        resultado["observacoes"].append("‚ùå ExcelGeneratorBRK n√£o encontrado")
    
    try:
        from processor.planilha_backup import salvar_planilha_inteligente
        resultado["planilha_backup_ok"] = True
        resultado["observacoes"].append("‚úÖ Sistema backup planilha dispon√≠vel")
    except ImportError:
        resultado["observacoes"].append("‚ùå Sistema backup planilha n√£o encontrado")
    
    # Verificar ONEDRIVE_BRK_ID
    import os
    if os.getenv('ONEDRIVE_BRK_ID'):
        resultado["onedrive_brk_ok"] = True
        resultado["observacoes"].append("‚úÖ ONEDRIVE_BRK_ID configurado")
    else:
        resultado["observacoes"].append("‚ùå ONEDRIVE_BRK_ID n√£o configurado")
    
    # Avalia√ß√£o final
    planilha_ok = (resultado["excel_generator_ok"] and 
                   resultado["planilha_backup_ok"] and 
                   resultado["onedrive_brk_ok"])
    
    if not planilha_ok:
        resultado["observacoes"].append("‚ö†Ô∏è Funcionalidade planilha n√£o dispon√≠vel")
    
    return resultado

def criar_monitor_brk(email_processor) -> MonitorBRK:
    """
    Factory function para criar monitor.
    
    Args:
        email_processor: Inst√¢ncia configurada de EmailProcessor
        
    Returns:
        MonitorBRK: Monitor pronto para uso
    """
    return MonitorBRK(email_processor)


def iniciar_monitoramento_automatico(email_processor) -> Optional[MonitorBRK]:
    """
    Fun√ß√£o de conveni√™ncia para app.py.
    Cria e inicia monitor em uma linha.
    
    Args:
        email_processor: EmailProcessor configurado
        
    Returns:
        MonitorBRK: Monitor ativo ou None se erro
    """
    try:
        monitor = criar_monitor_brk(email_processor)
        monitor.iniciar_monitoramento()
        return monitor
        
    except Exception as e:
        print(f"‚ùå Erro criando monitor autom√°tico: {e}")
        return None


# ============================================================================
# EXEMPLO DE USO (para testes e debug)
# ============================================================================

if __name__ == "__main__":
    print(f"üß™ TESTE DO MONITOR BRK")
    print(f"Este m√≥dulo deve ser importado pelo app.py")
    print(f"")
    print(f"üìã DEPEND√äNCIAS NECESS√ÅRIAS:")
    print(f"   ‚úÖ processor/email_processor.py ‚Üí m√©todos de processamento")
    print(f"   ‚úÖ processor/database_brk.py ‚Üí integra√ß√£o database (opcional)")
    print(f"   ‚úÖ auth/microsoft_auth.py ‚Üí autentica√ß√£o Microsoft")
    print(f"")
    print(f"üîß EXEMPLO DE USO NO APP.PY:")
    print(f"")
    print(f"  # 1. Import no topo")
    print(f"  from processor.monitor_brk import verificar_dependencias_monitor, iniciar_monitoramento_automatico")
    print(f"  ")
    print(f"  # 2. Verificar depend√™ncias (opcional - para debug)")
    print(f"  processor = EmailProcessor(auth_manager)")
    print(f"  deps = verificar_dependencias_monitor(processor)")
    print(f"  if not deps['dependencias_ok']:")
    print(f"      print('‚ùå Depend√™ncias faltando:', deps['observacoes'])")
    print(f"  ")
    print(f"  # 3. Iniciar monitor autom√°tico")
    print(f"  monitor = iniciar_monitoramento_automatico(processor)")
    print(f"")
    print(f"üìä LOGS ESPERADOS NO RENDER:")
    print(f"   üîÑ [14:35:00] MONITOR BRK - Verifica√ß√£o autom√°tica")
    print(f"   üìä ESTAT√çSTICAS PASTA BRK: 1,247 emails total, 23 m√™s atual")
    print(f"   üìß Email processado: CDC 513-01 ‚Üí Igreja Central ‚Üí R$ 127,45")
    print(f"   ‚úÖ Processamento conclu√≠do: 1 email, 1 PDF")
    print(f"   ‚è∞ Pr√≥xima verifica√ß√£o em 10 minutos")
